# -*- coding: utf-8 -*-
"""VRP 2opt python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nmx_jw-ejAmyFuQ-11ximEOzAQOnjI4U
"""

!python -m pip install -i https://pypi.gurobi.com gurobipy

from gurobipy import *

distance_matrix = [
    [0, 225.4, 351.3, 324.2, 204.8, 272.1, 349.7, 340.2, 386, 141.8, 269.8],
    [228.1, 0, 150.1, 123, 62.8, 113.6, 209.4, 190.9, 226.7, 103.6, 73.6],
    [303.5, 101.6, 0, 145.5, 124.1, 153.2, 263.8, 245.3, 244.6, 179, 86.1],
    [320.5, 123.2, 176.9, 0, 141.1, 115.8, 167.9, 149.4, 127.6, 196, 63.7],
    [211.2, 60.4, 174.2, 145.4, 0, 71.9, 160.7, 142.2, 188, 86.7, 92.8],
    [273.3, 107.8, 212.4, 113.9, 71.7, 0, 110.6, 92.1, 137.9, 148.8, 88.4],
    [355.4, 195.7, 306.5, 161, 149.5, 94.1, 0, 39.1, 102.8, 229.6, 182.5],
    [328.3, 162.8, 267.4, 121.9, 126.7, 55, 52.8, 0, 80.1, 203.8, 143.4],
    [409, 242.7, 303, 143.5, 203.2, 143.7, 129.3, 116.5, 0, 284.5, 195.7],
    [142.3, 104, 229.9, 202.8, 83.4, 150.7, 222.8, 215.5, 261.3, 0, 148.4],
    [270.3, 77.7, 127.5, 61.6, 90.9, 85.2, 195.8, 177.3, 172.5, 145.8, 0]
]

demands = [0, 51, 95, 54, 61, 30, 22, 15, 38, 42, 34]
vehicle_capacity = 150
num_vehicles = 3

# Create a model
m = Model("VRP")

# Variables
x = {}
for i in range(len(distance_matrix)):
    for j in range(len(distance_matrix)):
        x[i, j] = m.addVar(vtype=GRB.BINARY, name=f'x_{i}_{j}')

u = {}
for i in range(1, len(distance_matrix)):
    u[i] = m.addVar(vtype=GRB.CONTINUOUS, name=f'u_{i}')

# Objectives
m.setObjective(quicksum(distance_matrix[i][j] * x[i, j] for i in range(len(distance_matrix)) for j in range(len(distance_matrix))),
               GRB.MINIMIZE)

# Constraints
m.addConstrs((quicksum(x[i, j] for j in range(len(distance_matrix))) == 1 for i in range(1, len(distance_matrix))), name='outgoing_edges')
m.addConstrs((quicksum(x[i, j] for i in range(len(distance_matrix))) == 1 for j in range(1, len(distance_matrix))), name='incoming_edges')

m.addConstr(quicksum(x[0, j] for j in range(1, len(distance_matrix))) == num_vehicles, name='depot_outgoing')
m.addConstr(quicksum(x[i, 0] for i in range(1, len(distance_matrix))) == num_vehicles, name='depot_incoming')

m.addConstrs((u[i] - u[j] + vehicle_capacity * x[i, j] <= vehicle_capacity - demands[j] for i in range(1, len(distance_matrix)) for j in range(1, len(distance_matrix))), name='capacity_constraints')

# Solve
m.optimize()

# Solution
if m.status == GRB.OPTIMAL:
    print("Optimal solution found!")
    for i in range(len(distance_matrix)):
        for j in range(len(distance_matrix)):
            if x[i, j].x > 0.5:
                print(f"Vehicle {i} travels from Node {i} to Node {j}")
    print(f"Total length of the tours: {m.objVal}")
else:
    print("No optimal solution found.")

import pandas as pd
from gurobipy import *

# Load provided data
xl = pd.ExcelFile("Midterm-Data.xls")
sheet_names = xl.sheet_names

#first sheet contains distance data
distance_df = xl.parse(sheet_names[0], index_col=0)
demand_df = xl.parse(sheet_names[1], index_col=0)

# Convert data to lists
distance_matrix = distance_df.values.tolist()
demands = demand_df['demand'].tolist()

#dditional A data
vehicle_capacity = 150
num_vehicles = 3

# Create model
m = Model("VRP")

# Variables
x = {}
for i in range(len(distance_matrix)):
    for j in range(len(distance_matrix)):
        x[i, j] = m.addVar(vtype=GRB.BINARY, name=f'x_{i}_{j}')

u = {}
for i in range(1, len(distance_matrix)):
    u[i] = m.addVar(vtype=GRB.CONTINUOUS, name=f'u_{i}')

# Objective
m.setObjective(quicksum(distance_matrix[i][j] * x[i, j] for i in range(len(distance_matrix)) for j in range(len(distance_matrix))),
               GRB.MINIMIZE)


m.optimize()

def calculate_tour_length(tour, distance_matrix):
    tour_length = sum(distance_matrix[tour[i]][tour[i + 1]] for i in range(len(tour) - 1))
    return tour_length

def two_opt(tour, distance_matrix):
    current_tour = tour
    current_tour_length = calculate_tour_length(current_tour, distance_matrix)
    best_tour = current_tour
    best_tour_length = current_tour_length
    solution_improved = True

    while solution_improved:
        solution_improved = False
        for i in range(1, len(current_tour) - 2):
            for j in range(i + 1, len(current_tour) - 1):
                difference = (
                    distance_matrix[current_tour[i - 1]][current_tour[j]]
                    + distance_matrix[current_tour[i]][current_tour[j + 1]]
                    - distance_matrix[current_tour[i - 1]][current_tour[i]]
                    - distance_matrix[current_tour[j]][current_tour[j + 1]]
                )
                if current_tour_length + difference < best_tour_length:
                    best_tour = (
                        current_tour[:i]
                        + list(reversed(current_tour[i:j + 1]))
                        + current_tour[j + 1:]
                    )
                    best_tour_length = current_tour_length + difference
                    solution_improved = True

        current_tour_length = calculate_tour_length(best_tour, distance_matrix)
        current_tour = best_tour

    return best_tour, best_tour_length

initial_tour = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0]

# Improving tour using two-opt algorithm
improved_tour, improved_tour_length = two_opt(initial_tour, distance_matrix)

print("Initial tour:", initial_tour, "Length:", calculate_tour_length(initial_tour, distance_matrix))
print("Improved tour:", improved_tour, "Length:", improved_tour_length)

def vrp_two_opt(routes, distance_matrix):
    improved_routes = []

    for route in routes:
        improved_route, _ = two_opt(route, distance_matrix)
        improved_routes.append(improved_route)

    return improved_routes


initial_tour = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0]


# EXAMPLE: there are two routes in this code
routes = [initial_tour[:6], initial_tour[5:]]

# Improve each route using Two-Opt
improved_routes = vrp_two_opt(routes, distance_matrix)

print("Initial routes:", routes)
print("Improved routes:", improved_routes)